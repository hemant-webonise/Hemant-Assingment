
COMPARITIVE STUDY OF QUNIT, JASMINE, MOCHA 

TDD : [Test - Fix - Refactor]

TDD is Test Driven Development.

This means writing a test that fails because the specified functionality doesn’t exist, then writing the simplest code that can make the test pass, then refactoring to remove duplication. You repeat this Red-Green-Refactor loop over and over until you have a complete feature.

BDD : [Specs list - Fix ]

BDD is Behavior Driven Development. This means creating an executable specification that fails because the feature doesn’t exist, then writing the simplest code that can make the spec pass. You repeat this until a release candidate is ready to ship.

The key difference is the scope.

TDD is a development practice while BDD is a team methodology.
In TDD, the developers write the tests while in BDD the automated specifications are created by users or testers (with developers wiring them to the code under test.)

TDD is what you do when you’re unit-testing, and BDD is what you do when you’re writing customer-facing acceptance tests.

COMPARITIVE STUDY OF QUNIT, JASMINE, MOCHA

QUNIT :
Pros:

    Lots of support.

Cons:
    It's hard to configure
    Lacks fluent syntax
    Configuration difficult
    Asynchronous testing can be a bit of a headache
    No baked-in headless run support
---------------------------------------------------------------------------------------------------------------------------------------

JASMINE :

It requires a runner, such as Karma or Chutzpah, in most scenarios, but some distros (like the jasmine-node npm) have one baked in.

Pros:
    Simple setup for node through jasmine-node
    Jasmine takes a lot of cues from Rspec. So hits up for ruby Devolopers
    Headless running out of the box
    Nice fluent syntax for assertions built-in, and does play pretty well with other assertion libraries
    Supported by many CI servers (TeamCity, Codeship, etc.) and some that don’t support natively have plugins (jenkins has a maven plugin)
    Descriptive syntax for BDD paradigm

Cons:

    Asynchronous code will be the main problem area.
    Expects a specific suffix to all test files (*spec.js by default)
----------------------------------------------------------------------------------------------------------------------------------------

MOCHA
Pros:
    Sench Touch uses it.(I've worked on it so i will like it more)
    Simple setup, we need to have node js installed first.
    Headless running out of the box
    Allows use of any assertion library that will throw exceptions on failure, such as Chai
    Supported by some CI() servers and plugins for others (jenkins has a maven plugin)
    Has aliases for functions to be more BDD-oriented or TDD-oriented
    Highly extensible
    Asynchronous testing is a breeze

CASE STUDY:

MOCHA: 

[Frist thing : Testing asynchronous code]

Testing a promise means testing asynchronous code. We have no knowledge of when the asynchronous code will finish. Because of this we can’t just assign some value to a variable in the async callback and hope your test will catch it. This can be demonstrated easily by using a call to “setTimeout” within a Mocha test, using Chai as the expect framework.

Promises are used  in order to build Win8 / WinJS applications. It’s an absolute must because there is almost no way you can build an app without using them.

With the help of promise we can test asynchronous code.


[Secound thing : Command line support to test makes things very simple]

Simple to test code code on command line.

[Mocha is the testing framework and the chai is the expectation library]

Mocha is a test framework while Chai is an expectation one. Let's say Mocha setups and describes test suites and Chai provides convenient helpers to perform all kinds of assertions against your JavaScript code.

I have submitted in two forms have look to them.









